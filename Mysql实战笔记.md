### Mysql的执行过程

<img src="C:\Users\25699\AppData\Roaming\Typora\typora-user-images\image-20210730213500236.png" alt="image-20210730213500236" style="zoom:50%;" />

​                                                                Mysql的逻辑架构如图所示

1. #### ==连接器==

   连接器主要负责与客户端进行连接，获取权限，维持和管理连接

   查看连接：如果command是sleep代表的就是空闲连接

   ![image-20210730213850613](C:\Users\25699\AppData\Roaming\Typora\typora-user-images\image-20210730213850613.png)

   数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

   

   如果全部使用长连接会导致内存涨的特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

   **解决方案：**

   - 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
   - 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

2. #### ==查询缓存==

查询缓存也就是说查询的时候首先看缓存中有没有数据（缓存中的数据采用的格式是 K-V键值对，其中K代表的是“sql语句”，V代表的是查询的结果）

 查询缓存的效率很低，这是因为如果有对表的更新，就会将整个缓存全部清空。在MySQL8.0  直接     将缓存功能删除掉了

3. #### ==分析器==

如果没有命中缓存就要执行sql语句了，首先要做的就是对sql语句进行解析，分析器会将语句进行   语法分析

~~~mysql
select SQL_CACHE * from T where ID=10；
~~~

MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”

4. #### ==优化器==

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：

~~~mysql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
~~~

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

5. #### ==执行器==

   执行的流程如下（假设ID没有索引）：

   - 调用InnoDB引擎接口取这个表的第一行，判断ID是否是10，如果不是就跳过，是就将结果存储在结果集中。
   - 调用引擎接口取下一行，重复判断逻辑，直到取到最后一行
   - 将结果集返回给客户端

   

### 日志系统

更新语句的执行过程和查询流程类似，但是更新语句还涉及到了两个重要的日志模块。即redo log（重做日志）和 binlog（归档日志）

#### 重要的日志模块： redo log

具体来说，当有一条记录需要更新的时候，==InnoDB 引擎==就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

redo log的大小固定

<img src="C:\Users\25699\AppData\Roaming\Typora\typora-user-images\image-20210730220203607.png" alt="image-20210730220203607" style="zoom:50%;" />

write_pos记录当前记录的位置，一边写一边后移，写到第三个后面就回到0号文件开头。checkpoint记录的是当前要擦除的位置，也是往后移动并且循环的。==擦除之前要讲记录更新到磁盘文件==write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。

有了 redo log，==InnoDB== 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 **crash-safe**。

#### 重要的日志模块：binlog

redo log是InnoDB引擎独有的日志，在server也有自己的日志 就是binlog（归档日志）

<u>**两者的区别**：</u>

1. redo log 是 ==InnoDB 引擎特有==的；binlog 是 MySQL 的 ==Server 层==实现的，==所有引擎都可以使用==。
2. redo log 是==物理日志，==记录的是“在某个数据页上做了什么修改”；binlog 是==逻辑日志==，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是==循环==写的，空间固定会用完；binlog 是可以==追加==写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



**update 语句时的内部流程：**

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

   浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

<img src="C:\Users\25699\AppData\Roaming\Typora\typora-user-images\image-20210730221512839.png" alt="image-20210730221512839" style="zoom:67%;" />

上图可以看出 redo log的写入拆分成了prepare 和 commit，这就是"两阶段提交"

原因：为了让两份日志之间的逻辑一致

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

> redo log记录的是当时的数据是怎么变化的，比如备份的时候记录table表中字段a的值是1→3（由1变成3），而binlog里面记录可能就是多条SQL执行之后a的值才等于3，比如update table set a =1 where ID=1；update table set a=3 where ID=1；或者执行过更多SQL才变成3。